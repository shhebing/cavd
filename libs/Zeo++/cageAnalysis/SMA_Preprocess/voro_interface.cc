// Voro++, a 3D cell-based Voronoi library
//
// voro_interface.cc
//
// Routines for interfacing with voro++ classes
//
// Author   : Ismael Gomez Garcia
// Email    : 
// Date     : November 23rd 2015

#include "voro_interface.hh"


bool IsBoundaryPoint(		const double point[DIM_SMA],
							const double x_boundary[2],
							const double y_boundary[2],
							const double z_boundary[2])
{

	/*
	// The point is in one of the Y-Z boundary planes
	if (point[X_COORD] == x_boundary[0] || point[X_COORD] == x_boundary[1]) 
		return true;

	// The point is in one of the X-Z boundary planes
	if (point[Y_COORD] == y_boundary[0] || point[Y_COORD] == y_boundary[1])
		return true;

	// The point is in one of the Y-X boundary planes
	if (point[Z_COORD] == z_boundary[0] || point[Z_COORD] == z_boundary[1])
		return true;*/

	double 	x_diff = 0.05*abs(x_boundary[1] - x_boundary[0]),
			y_diff = 0.05*abs(y_boundary[1] - y_boundary[0]),
			z_diff = 0.05*abs(z_boundary[1] - z_boundary[0]);

	// The point is in one of the Y-Z boundary planes
	if ( abs(point[X_COORD] - x_boundary[0]) < x_diff || abs(point[X_COORD] - x_boundary[1]) < x_diff)
		return true;

	// The point is in one of the X-Z boundary planes
	if ( abs(point[Y_COORD] - y_boundary[0]) < y_diff || abs(point[Y_COORD] - y_boundary[1]) < y_diff)
		return true;

	// The point is in one of the Y-X boundary planes
	if ( abs(point[Z_COORD] - z_boundary[0]) < z_diff || abs(point[Z_COORD] - z_boundary[1]) < z_diff)
		return true;

	// The point is not in any of such planes (not boundary)
	return false;



}

double PointsDistance (		double Point1[DIM_SMA],
							double Point2[DIM_SMA])
{

	double V[DIM_SMA];

	for (int i = 0; i < DIM_SMA; i++)
		V[i]=Point1[i]-Point2[i];

	return sqrt(V[X_COORD]*V[X_COORD] + V[Y_COORD]*V[Y_COORD] + V[Z_COORD]*V[Z_COORD]);


}


/*	ComputeEdgeRadius: 
 *	Computes the radius of an edge given by the coordinates of the points composing it and the centre of the cell.
 */
double ComputeEdgeRadius( 	double Point1[DIM_SMA], 
							double Point2[DIM_SMA],
							double Centre[DIM_SMA])
{

	// Vectors for distance calculation
	double U[DIM_SMA], E[DIM_SMA], ProyE[DIM_SMA], V[DIM_SMA];

	// Modules for vectors
	double ModU, ModV;

	// Lengths
	double Lambda1;


	//	VECTOR SUBSPACE
	//	Straight line connecting Point 1 and Point 2
	// 	U vector: unitary vector base of the vector subspace: S = <U>
	for (int i = 0; i < DIM_SMA; i++)
		U[i]=Point2[i]-Point1[i];
	
	ModU = sqrt(U[X_COORD]*U[X_COORD] + U[Y_COORD]*U[Y_COORD] + U[Z_COORD]*U[Z_COORD]);

	for (int i = 0; i < DIM_SMA; i++)
		U[i]=U[i]/ModU;

	//	ORTHOGONAL PROJECTION
	//	Vector formed by Point1-Centre is projected into <U>
	//	E = Centre-Point1
	//	U := p(E)

	// E vector: vector connecting Point1 with center (not unitary)
	for (int i = 0; i < DIM_SMA; i++)
		E[i]=Centre[i]-Point1[i];
	
	// Compute the orthogonal projection of the centre point over the Point1-Point2 line
	//Lambda1 = (U[X_COORD]*E[X_COORD] + U[Y_COORD]*E[Y_COORD] + U[Z_COORD]*E[Z_COORD])/(U[X_COORD]*U[X_COORD] + U[Y_COORD]*U[Y_COORD] + U[Z_COORD]*U[Z_COORD]);
	Lambda1 = U[X_COORD]*E[X_COORD] + U[Y_COORD]*E[Y_COORD] + U[Z_COORD]*E[Z_COORD];

	// U vector redefined: orthogonal projection of E into the subspace generated by U
	for (int i = 0; i < DIM_SMA; i++)
		ProyE[i] = U[i]*Lambda1;

	// 	DISTANCE
	//	Compute V = E-p(E)
	//	Compute ||V||

	for (int i = 0; i < DIM_SMA; i++)
		V[i]=E[i]-ProyE[i];

	ModV = sqrt( V[X_COORD]*V[X_COORD] + V[Y_COORD]*V[Y_COORD] + V[Z_COORD]*V[Z_COORD] );


	//	RETURN
	//	Distance between the centre of the cell and the edge formed by the two points given.

	return ModV;


}

void CalculateBoundaries (	double *BoundRef,
							int Coordinate,
							Complex *Chemical)
{

	double Max, Min;

	Max = Min = Chemical->GetPointList()[0]->GetCoordinate(Coordinate);

	for (int i = 1; i < Chemical->GetNPoints(); i++)
	{
		if (Chemical->GetPointList()[i]->GetCoordinate(Coordinate) > Max) {
			Max = Chemical->GetPointList()[i]->GetCoordinate(Coordinate);
		}
		if (Chemical->GetPointList()[i]->GetCoordinate(Coordinate) < Min) {
			Min = Chemical->GetPointList()[i]->GetCoordinate(Coordinate);
		}
	}

	// Store the boundaries: Maximum distances + 10%
	BoundRef[0] = Min-0.1*abs(Min);
	BoundRef[1] = Max+0.1*abs(Max);

}

Complex *ComputeVoronoi( Complex *Chemical )
{

	int NAtoms = Chemical->GetNPoints();

	/////	VORO++: VORONOI TESSELLATION
	///		Compute the boundaries (distance of the maximum components to the origin +10%).
	//		Insert the points into a container_poly type object.
	//		Compute voronoi tessellation.

	double  x_bound_ref[2] = {0.,0.},
			y_bound_ref[2] = {0.,0.},
			z_bound_ref[2] = {0.,0.};

	CalculateBoundaries(x_bound_ref, X_COORD, Chemical);
	CalculateBoundaries(y_bound_ref, Y_COORD, Chemical);
	CalculateBoundaries(z_bound_ref, Z_COORD, Chemical);

	//cout << "Boundaries: X - " << x_bound_ref[0] << "," << x_bound_ref[1] << " Y " << y_bound_ref[0] << "," << y_bound_ref[1] << " Z " << z_bound_ref[0] << "," << z_bound_ref[1] << endl;


	// Create object
	container_poly VoroContainer( x_bound_ref[0], x_bound_ref[1], y_bound_ref[0], y_bound_ref[1], z_bound_ref[0], z_bound_ref[1], 1, 1, 1, false, false, false, 8);

	// Insert the points into the container
	for (int i = 0; i < NAtoms; i++)
	{
		Point *PAux = Chemical->GetPointList()[i];
		//cout << "Step " << i << "- Inserting point:" << endl;
		//PAux->PrintPoint(); cout << endl;
		VoroContainer.put(PAux->GetPointId(), PAux->GetCoordinate(X_COORD), PAux->GetCoordinate(Y_COORD), PAux->GetCoordinate(Z_COORD), PAux->GetRadius() );
		//VoroContainer.put(i, PAux->GetCoordinate(X_COORD), PAux->GetCoordinate(Y_COORD), PAux->GetCoordinate(Z_COORD), PAux->GetRadius() );
	}

	NAtoms = VoroContainer.co[0];
	//cout << "Atoms read " << NAtoms << " - Atoms expected " << Chemical->GetNPoints() << endl;

	voronoicell *VoroCellList = new voronoicell[NAtoms];

	c_loop_all LoopOverAll(VoroContainer);

	voro_compute<container_poly> VC(VoroContainer, 1, 1, 1);

	// Compute all the Voronoi cells
	int Count = 0;
	if(LoopOverAll.start()) do
	{
		VC.compute_cell(VoroCellList[Count], LoopOverAll.ijk, LoopOverAll.q, LoopOverAll.i, LoopOverAll.j, LoopOverAll.k);
		Count++;
		//cout << "ijk: " << LoopOverAll.ijk << "; q: " << LoopOverAll.q << "; i: " << LoopOverAll.i << "; j: " << LoopOverAll.j << "; k: " << LoopOverAll.k << "\n";
	}
	while(LoopOverAll.inc());


	/////	SINGLE_MOLECULE_ANALYSIS - RETRIEVE THE VORONOI TESSELLATION TO COMPLEX
	///		Retrieve the points and insert them in the complex (if not present).
	//		Retrieve the edges and insert them in the complex (if not present). Check if points connected are also present.

	Complex *MolVoronoi = new Complex();

	double Centre[DIM_SMA], PointAux[DIM_SMA], PointAux2[DIM_SMA];

	for (int i = 0; i < NAtoms; i++)
	{

		//double Centre[DIM_SMA];

		// Compute centre of voronoi cell
		//VoroCellList[i].centroid(Centre[X_COORD], Centre[Y_COORD], Centre[Z_COORD]);
		Centre[X_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+X_COORD];
		Centre[Y_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+Y_COORD];
		Centre[Z_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+Z_COORD];

		double AtomRadius = VoroContainer.p[0][i*(DIM_SMA+1)+RADIUS_COORD];

		//cout << AtomRadius << endl;

		//cout << "Center: " << Centre[X_COORD] << " " << Centre[Y_COORD] << " " << Centre[Z_COORD] << "\n";
		//cout << "N " << i << " Complex?" << MolVoronoi->GetNPoints() << " Atoms" << NAtoms << endl;


		// For every point in the current voronoi cell
		for (int j = 0; j < VoroCellList[i].p; j++)
		{
			//double PointAux[DIM_SMA];

			//cout << "From voronoi " << 0.5*VoroCellList[i].pts[DIM_SMA*j+X_COORD] + Centre[X_COORD] << " " << 0.5*VoroCellList[i].pts[DIM_SMA*j+Y_COORD] + Centre[Y_COORD] << " " << 0.5*VoroCellList[i].pts[DIM_SMA*j+Z_COORD] + Centre[Z_COORD] << endl;

			// Read point info of current voronoi node and sum the center of such node
			PointAux[X_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+X_COORD] + Centre[X_COORD];
			PointAux[Y_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+Y_COORD] + Centre[Y_COORD];
			PointAux[Z_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+Z_COORD] + Centre[Z_COORD];

			//cout << "P: " << PointAux[X_COORD] << " " << PointAux[Y_COORD] << " " << PointAux[Z_COORD] << "\n";

			// Calculate square radius of the point
			//RadiusAux = PointsDistance(PointAux, Centre) - AtomRadius*AtomRadius;

			//double RadiusAux = PointsDistance(PointAux, Centre);
			double RadiusAux = PointsDistance(PointAux, Centre) - AtomRadius;
			if (RadiusAux < 0) RadiusAux = 0;

			// Insert new point sharing info (if not in complex yet)
			if (MolVoronoi->GetPointByCoordinates(PointAux) == NULL )
			{
				if (IsBoundaryPoint(PointAux, x_bound_ref, y_bound_ref, z_bound_ref))
				{
					MolVoronoi->InsertPointByValue(PointAux, RadiusAux, boundary_point);
				}
				else
				{
					MolVoronoi->InsertPointByValue(PointAux, RadiusAux, undefined_point);
				}
			}
			//else { cout << "Repeated point detected" << PointCount << " \n" ; 	}

		} // End for j

		// Insert the centre as a "atom_point" type point
		// TODO Decide if this should be part of the complex or not
		//MolVoronoi->InsertPointByValue(Centre, AtomRadius, atom_point);

	} // End for i

	//	EDGES
	// 	Edges has to be created only after points, so they are created independently to avoid errors. The computational order does not change except for a few copy operations.
	for (int i = 0; i < NAtoms; i++)
	{

		// Compute the centre of the cell
		//double Centre[DIM_SMA];

		Centre[X_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+X_COORD];
		Centre[Y_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+Y_COORD];
		Centre[Z_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+Z_COORD];
		//cout << "Center: " << Centre[X_COORD] << " " << Centre[Y_COORD] << " " << Centre[Z_COORD] << "\n";


		// For every point in the voronoi cell
		for (int j = 0; j < VoroCellList[i].p; j++)
		{
			//double PointAux[DIM_SMA];

			PointAux[X_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+X_COORD] + Centre[X_COORD];
			PointAux[Y_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+Y_COORD] + Centre[Y_COORD];
			PointAux[Z_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+Z_COORD] + Centre[Z_COORD];

			// For every edge connected to the point
			for (int k = 0; k < VoroCellList[i].nu[j]; k++)
			{
				//double PointAux2[DIM_SMA];

				// Index of the point at the other end of the edges
				int IndexPoint = VoroCellList[i].ed[j][k];

				// Coordinates of the point at the other end of the edge
				PointAux2[X_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*IndexPoint+X_COORD] + Centre[X_COORD];
				PointAux2[Y_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*IndexPoint+Y_COORD] + Centre[Y_COORD];
				PointAux2[Z_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*IndexPoint+Z_COORD] + Centre[Z_COORD];

				// Compute the radius of the edge
				double RadiusAux = ComputeEdgeRadius(PointAux, PointAux2, Centre);

				//cout << "Edge radius " << RadiusAux << endl;

				// Check if the edge exists, insert if not
				if (MolVoronoi->GetEdgeByCoordinates(PointAux, PointAux2) == NULL)
				{
					// Insert the edge - note that the radius of the edge and the points associated shall be the same
					MolVoronoi->InsertEdgeByValue(MolVoronoi->GetPointByCoordinates(PointAux), MolVoronoi->GetPointByCoordinates(PointAux2), RadiusAux);

					// Increase by one the degree of the nodes connected
					MolVoronoi->GetPointByCoordinates(PointAux)->IncreaseDegree(1);
					MolVoronoi->GetPointByCoordinates(PointAux2)->IncreaseDegree(1);
				}

			}
		}
	}

	// Deallocate voronoi cell list
	delete[] VoroCellList;

	return MolVoronoi;


}

Complex *ComputeVoronoiFromFile(	double x_boundary[2],
									double y_boundary[2],
									double z_boundary[2],
									char *Filename		)
{

	int i, j, k;

	int NAtoms = 0; // = 78;

	int IndexPoint;

	double PointAux[DIM_SMA], PointAux2[DIM_SMA], RadiusAux, AtomRadius;

	double Centre[DIM_SMA] = {0.,0.,0.};

	double x_bound_ref[2], y_bound_ref[2], z_bound_ref[2];

	x_bound_ref[0] = x_boundary[0]; x_bound_ref[1] = x_boundary[1];
	y_bound_ref[0] = y_boundary[0]; y_bound_ref[1] = y_boundary[1];
	z_bound_ref[0] = z_boundary[0]; z_bound_ref[1] = z_boundary[1];

	// COMPLEX	Variables for complex creation
	//		Complex variable
	//		Arrays for edge list and point list (empty)

	Complex *Molecule;
	Point **PointList = new Point*[COMPLEX_MAX_POINTS];
	Edge **EdgeList = new Edge*[COMPLEX_MAX_EDGES];

	Molecule = new Complex (PointList, EdgeList, 0, 0);


	// VORO++	Variables for Voro++ computation
	//		Container, loop and voronoicell list
	//		voro_compute object for processing

	/*container_poly VoroContainer(	x_boundary[0], x_boundary[1],
					y_boundary[0], y_boundary[1],
					z_boundary[0], z_boundary[1],
					6, 6, 6, 
					false, false, false,8);	*/

	container_poly VoroContainer( x_bound_ref[0], x_bound_ref[1], y_bound_ref[0], y_bound_ref[1], z_bound_ref[0], z_bound_ref[1], 1, 1, 1, false, false, false, 8);	

	voro_compute<container_poly> VC(VoroContainer, 1, 1, 1);
	//voro_compute<container> VC(VoroContainer, 1, 1, 1);

	c_loop_all LoopOverAll(VoroContainer);

	voronoicell *VoroCellList;
	//voronoicell_neighbor *VoroCellList;

	
	// VORONOI 		Throught voro++ routines
	// TESSELLATION		Create the list of voronoi cells
	//			Import data from file
	//			Compute cell by cell and store in VoroCellList			

	// Import particles in the container

	//VoroContainer.import("/Users/ismael.gomez/Documents/Software/Voro++/voro_extended/Molecules/AC2a");
	VoroContainer.import(Filename);

	// TODO: extract number of atoms
	NAtoms = VoroContainer.co[0];
	VoroCellList = new voronoicell[NAtoms];
	//VoroCellList = new voronoicell_neighbor[NAtoms];

	//cout << "Number of atoms: " << NAtoms << "\n";//


	i = 0;
	if(LoopOverAll.start()) do
	{ 
		VC.compute_cell(VoroCellList[i], LoopOverAll.ijk, LoopOverAll.q, LoopOverAll.i, LoopOverAll.j, LoopOverAll.k);
		i++;
		//cout << "ijk: " << LoopOverAll.ijk << "; q: " << LoopOverAll.q << "; i: " << LoopOverAll.i << "; j: " << LoopOverAll.j << "; k: " << LoopOverAll.k << "\n";
	}
	while(LoopOverAll.inc());

	
	// COPY: 	Read the information about the points and edges of each voronoi cell
	// 		Check if the points are already in the complex (note that voronoi cells will share some vertices)
	//		Same for the edges
	//		Insert the points and edges into the complex if they were not there

	//	POINTS
	for (i = 0; i < NAtoms; i++)
	{
		
		// Compute centre of voronoi cell
		//VoroCellList[i].centroid(Centre[X_COORD], Centre[Y_COORD], Centre[Z_COORD]);
		Centre[X_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+X_COORD];
		Centre[Y_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+Y_COORD];
		Centre[Z_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+Z_COORD];

		AtomRadius = VoroContainer.p[0][i*(DIM_SMA+1)+DIM_SMA];

		//cout << "Center: " << Centre[X_COORD] << " " << Centre[Y_COORD] << " " << Centre[Z_COORD] << "\n";

		
		// For every point in the current voronoi cell
		for (j = 0; j < VoroCellList[i].p; j++)
		{
			// Read point info of current voronoi node and sum the center of such node
			PointAux[X_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+X_COORD] + Centre[X_COORD];
			PointAux[Y_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+Y_COORD] + Centre[Y_COORD];
			PointAux[Z_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+Z_COORD] + Centre[Z_COORD];

			//cout << "P: " << PointAux[X_COORD] << " " << PointAux[Y_COORD] << " " << PointAux[Z_COORD] << "\n";

			// Calculate square radius of the point
			//RadiusAux = PointsDistance(PointAux, Centre) - AtomRadius*AtomRadius;
			RadiusAux = PointsDistance(PointAux, Centre);

			// Insert new point sharing info (if not in complex yet)
			if (Molecule->GetPointByCoordinates(PointAux) == NULL )	
			{
				if (IsBoundaryPoint(PointAux, x_boundary, y_boundary, z_boundary))
				{
					Molecule->InsertPointByValue(PointAux, RadiusAux, boundary_point);
				}
				else
				{
					Molecule->InsertPointByValue(PointAux, RadiusAux, undefined_point);
				}
			}
			//else { cout << "Repeated point detected" << PointCount << " \n" ; 	}
	
		} // End for j

		// Insert the centre as a "atom_point" type point
		// TODO Decide if this should be part of the complex or not
		//Molecule->InsertPointByValue(Centre, AtomRadius, atom_point);	

	} // End for i

	

	//	EDGES
	// 	Edges has to be created only after points, so they are created independently to avoid errors. The computational order does not change except for a few copy operations.
	for (i = 0; i < NAtoms; i++)
	{

		// Compute the centre of the cell
		//VoroCellList[i].centroid(Centre[X_COORD], Centre[Y_COORD], Centre[Z_COORD]);	
		Centre[X_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+X_COORD];
		Centre[Y_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+Y_COORD];
		Centre[Z_COORD] = VoroContainer.p[0][i*(DIM_SMA+1)+Z_COORD];
		//cout << "Center: " << Centre[X_COORD] << " " << Centre[Y_COORD] << " " << Centre[Z_COORD] << "\n";
	

		// For every point in the voronoi cell
		for (j = 0; j < VoroCellList[i].p; j++)
		{
			

			PointAux[X_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+X_COORD] + Centre[X_COORD];
			PointAux[Y_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+Y_COORD] + Centre[Y_COORD];
			PointAux[Z_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*j+Z_COORD] + Centre[Z_COORD];

			/*PointAux[X_COORD] = VoroCellList[i].pts[DIM_SMA*j+X_COORD];
			PointAux[Y_COORD] = VoroCellList[i].pts[DIM_SMA*j+Y_COORD];
			PointAux[Z_COORD] = VoroCellList[i].pts[DIM_SMA*j+Z_COORD];*/
			
			// For every edge connected to the point
			for (k = 0; k < VoroCellList[i].nu[j]; k++)
			{

				// Index of the point at the other end of the edges
				IndexPoint = VoroCellList[i].ed[j][k];

				// Coordinates of the point at the other end of the edge
				PointAux2[X_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*IndexPoint+X_COORD] + Centre[X_COORD];
				PointAux2[Y_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*IndexPoint+Y_COORD] + Centre[Y_COORD];
				PointAux2[Z_COORD] = 0.5*VoroCellList[i].pts[DIM_SMA*IndexPoint+Z_COORD] + Centre[Z_COORD];

				/*PointAux2[X_COORD] = VoroCellList[i].pts[DIM_SMA*IndexPoint+X_COORD];
				PointAux2[Y_COORD] = VoroCellList[i].pts[DIM_SMA*IndexPoint+Y_COORD];
				PointAux2[Z_COORD] = VoroCellList[i].pts[DIM_SMA*IndexPoint+Z_COORD];*/

				// Compute the radius of the edge
				RadiusAux = ComputeEdgeRadius(PointAux, PointAux2, Centre);

				// Check if the edge exists, insert if not
				if (Molecule->GetEdgeByCoordinates(PointAux, PointAux2) == NULL)
				{
					// Insert the edge - note that the radius of the edge and the points associated shall be the same
					Molecule->InsertEdgeByValue(Molecule->GetPointByCoordinates(PointAux), Molecule->GetPointByCoordinates(PointAux2), RadiusAux);

					// Increase by one the degree of the nodes connected
					Molecule->GetPointByCoordinates(PointAux)->IncreaseDegree(1);
					Molecule->GetPointByCoordinates(PointAux2)->IncreaseDegree(1);
				}
				
			}
		}
	}

	// Delete voronoi structures
	//delete VoroCellList;


	
	return Molecule;
	

}







// VORO_INTERFACE_CC
